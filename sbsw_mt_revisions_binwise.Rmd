---
title: "sbsw_mt_revisions_binwise"
output: html_document
date: "2024-02-06"
---

This script contains revised data analysis and figures for the SBSW manuscript while retaining the bin-wise nature of the differential expression analysis (ie each DESeq2 analysis was generated by the genes specific to a given bin, then all stitched together into one results table)

Pros: 
1. Specificity of understanding up/down-regulated genes in a given genome, genome-wise trends

Cons:
1. Are p-values and LFC values comparable if they are not generated all together? 

#load packages 
```{r}
library(tidyverse)
library(DESeq2)
library(wesanderson)

```

#load data
```{r}
#load data
mt_tally <-read_csv("../current_data/mt_tally_v2.csv") #raw data from bwa
metadata_norm_v2 <-read_csv("metadata_norm_v2.csv") #metadata
master_tax <-read_csv("../current_data/master_genes_taxonomy_gtdbtk_blocked.csv") %>% select(-"...1")
diffex_tax <-master_tax %>% filter(padj <0.05)
normalized_counts <-read_csv("../current_data/normalized_mt_tally_v2_genes.csv")
corrected_counts <-read_csv("../current_data/limma_corrected_counts.csv")

#load visuals
plot_theme <- theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5), axis.text = element_text(color = "black"))

wes_palette_20 <-c(wes_palette("Cavalcanti1"), wes_palette("GrandBudapest1"), wes_palette("AsteroidCity2"), wes_palette("GrandBudapest2"), wes_palette("IsleofDogs2"))
```

#MA plot of fold change vs base mean for all genes in the dataset

The DESeq2 internal MA plot uses the function plotMA from geneplotter. Since we no longer have a deseq2 dataset format, I can simply use geneplotter to generate my MA plot.
```{r}
install.packages("geneplotter")
library(geneplotter)

master_tax <-as.data.frame(master_tax)
master_tax$significance <-"FALSE"
master_tax$significance[master_tax$padj < 0.05] <- "TRUE"
master_tax$significance <-as.logical(master_tax$significance)

MA_plot <-master_tax %>% select(-c(3:14))
MA_plot <-MA_plot[,c("baseMean", "log2FoldChange", "significance")]
plotMA(MA_plot, ylim=c(-3,3))

```

#PCA plot of overall sample differences 

PCA test to visualize batch effects on the data in DESeq:
```{r}

#create matrix from mt_tally and call this mt_raw
mt_raw <- mt_tally[,c(1, 5:40)]
mt_raw <- as.data.frame(mt_raw)
rownames(mt_raw) <-mt_raw$position
mt_raw[,"position"] <- NULL

dds <- DESeqDataSetFromMatrix(countData=mt_raw,
                              colData=metadata_norm_v2,
                              design=~extraction_batch + timecount_norm) #load deseq2 dataset 


dds <- estimateSizeFactors( dds ) #normalizing data by gene length and rna counts

save(dds, file="raw_deseq_dataset.Rdata")

sizeFactors(dds)

vsd <-vst(dds, blind=FALSE) #variance stabilizing transformation that is not blind to design. Design is used to calculate variability but not remove it 

plotPCA(vsd, intgroup=c("time24", "extraction_batch")) + scale_color_brewer(palette="Paired") #visualize the PCA plot of data before batch effects are removed-- batch accounts for ~22% of the variation and is a significant variable

```

Using limma to remove batch effects from the variance stabilized count matrix:

```{r}
mat <- assay(vsd)
mm <- model.matrix(~timecount_norm, colData(vsd))
mat <- limma::removeBatchEffect(mat, batch=vsd$extraction_batch, design=mm)
assay(vsd) <- mat
plotPCA(vsd, intgroup=c("time24", "extraction_batch_numeric", "pH", "temperature", "DO_sat", "Aw (in situ)")) + scale_color_brewer(palette="Paired")

#this limma-corrected matrix can be used for downstream applications independent of deseq2 such as pca, statistical testing, etc. it should NOT be used as the input for deseq2 as it is not raw count data! deseq2 will remove batch effects internally if they are included in the design 


write.csv(mat, "limma_corrected_counts.csv")

#PCA plot outside deseq2
pcadata <- plotPCA(vsd, intgroup=c("time24", "extraction_batch", "pH", "temperature", "DO_sat", "Aw (in situ)", "light_condition", "time"), returnData=TRUE)
#This gives me the position of each sample within PC1 and PC2, but not any other information about PCs. Good for plotting but less good for analysis
```

#Plotting PCA in ggplot to customize graphics:

```{r}
ggplot(pcadata, aes(x=PC1, y=PC2)) +
  geom_point(size=3, aes(color=time, shape=extraction_batch)) +
  stat_ellipse(mapping=aes(linetype=light_condition)) +
  scale_color_brewer(palette="Paired") +
  plot_theme
  
```



How best to visualize the whole dataset?  showing overall differences btwn samples and that there is truly a day/night difference? 

"Note that lack of clustering in a PCA does not mean nothing is happening. Imagine an RNAseq experiment where only a dozen genes changed due to your treatment. Because thereâ€™s few genes, transcriptome-wide you might not capture structure in the data."
PCA plot using prcomp and ggbiplot:
https://tavareshugo.github.io/data-carpentry-rnaseq/03_rnaseq_pca.html
```{r}
library(devtools)
library(ggbiplot)

#Put dataframe of limma-corrected counts in a format accepted by prcomp

#pcadf <-corrected_counts %>% pivot_longer(!position, names_to="sample", values_to="corrected_count") %>% left_join(., metadata_norm_v2[,c(2, 5:10, 12)], by="sample")

#create data matrix from corrected_counts

pca_matrix <- corrected_counts %>% column_to_rownames("position") %>% as.matrix() %>% t()
#see how it looks 
pca_matrix[1:10, 1:5] #samples are rows, columns are variables (genes)

sample_pca <-prcomp(pca_matrix)
pc_eigenvalues <-sample_pca$sdev^2

# create a "tibble" manually with 
# a variable indicating the PC number
# and a variable with the variances
pc_eigenvalues <- tibble(PC = factor(1:length(pc_eigenvalues)), 
                         variance = pc_eigenvalues) %>% 
  # add a new column with the percent variance
  mutate(pct = variance/sum(variance)*100) %>% 
  # add another column with the cumulative variance explained
  mutate(pct_cum = cumsum(pct))

# print the result
pc_eigenvalues

#create scree plot to viaualize this
pc_eigenvalues %>% 
  ggplot(aes(x = PC)) +
  geom_col(aes(y = pct)) +
  geom_line(aes(y = pct_cum, group = 1)) + 
  geom_point(aes(y = pct_cum)) +
  labs(x = "Principal component", y = "Fraction variance explained")

```

PC1 and PC2 do NOT explain most of the variation in the dataset. Perhaps a non-linear method, like NMDS, would work better? Unsure why it looks so different from the PCA plot generated with plotPCA in DESeq2?
#Could try it on un-corrected data?
```{r}
pca_matrix <- normalized_counts[,c(1:37)] %>% column_to_rownames("position") %>% as.matrix() %>% t() 
#see how it looks 
pca_matrix[1:10, 1:5] #samples are rows, columns are variables (genes)

sample_pca <-prcomp(pca_matrix, scale=TRUE)
pc_eigenvalues <-sample_pca$sdev^2

# create a "tibble" manually with 
# a variable indicating the PC number
# and a variable with the variances
pc_eigenvalues <- tibble(PC = factor(1:length(pc_eigenvalues)), 
                         variance = pc_eigenvalues) %>% 
  # add a new column with the percent variance
  mutate(pct = variance/sum(variance)*100) %>% 
  # add another column with the cumulative variance explained
  mutate(pct_cum = cumsum(pct))

# print the result
pc_eigenvalues

#create scree plot to viaualize this
pc_eigenvalues %>% 
  ggplot(aes(x = PC)) +
  geom_col(aes(y = pct)) +
  geom_line(aes(y = pct_cum, group = 1)) + 
  geom_point(aes(y = pct_cum)) +
  labs(x = "Principal component", y = "Fraction variance explained")

pc_scores <- sample_pca$x
pc_scores <- pc_scores %>% 
  # convert to a tibble retaining the sample names as a new column
  as_tibble(rownames = "sample")

# print the result
pc_scores

pc_scores %>% 
  # create the plot
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point()

#scaled or unscaled, it's a mess
```

#How about NMDS?
#Nope it looks confusing 
```{r}
library(vegan)
pca_matrix <- corrected_counts %>% column_to_rownames("position") %>% as.matrix() %>% t() 
#see how it looks 
pca_matrix[1:10, 1:5] #samples are rows, columns are variables (genes)
ord <- metaMDS(pca_matrix, k=2)
data.scores=as.data.frame(scores(ord))
data.scores$sample <-rownames(data.scores)

nmds_plot <-left_join(data.scores, metadata_norm_v2, by="sample")

#color is time
ggplot(nmds_plot, aes(x=NMDS1, y=NMDS2)) +
  geom_point(size=3, aes(color=time, shape=extraction_batch)) + 
  plot_theme 
  

```


#Looking for most highly expressed genomes

```{r}
hits_per_bin <- master_tax %>% group_by(bin) %>% summarize(hits_per_bin=length(bin))

diffex_hits <-diffex_tax %>% group_by(bin) %>% summarize(diffex_hits=length(bin)) 

prop_diffex <-left_join(diffex_hits, hits_per_bin, by="bin") %>% mutate(prop_genome_diffex=diffex_hits/hits_per_bin)
```

Many of these genomes are the same as those I've identified with interesting results in sod, etc

#bacteriorhodopsins
How to locate real bacteriorhodopsin genes vs homologs? 
```{r}
rhodopsin <-diffex_tax %>% filter(product=="bacteriorhodopsin")
#n=24 genes
ggplot(rhodopsin, aes(x=position, y=baseMean, fill=family)) +
  geom_bar(stat="identity")

all_rhodopsin <-master_tax %>% filter(product=="bacteriorhodopsin")

#creating a line plot showing the relative expression of these genes to their base mean value
#this cannot be done for batch-corrected count data since it is log transformed

#counts for all bacteriorhodopsin genes (not corrected!)
rhodopsin_counts <-normalized_counts %>% filter(position %in% rhodopsin$position) %>% pivot_longer(c(1:36), names_to="sample") %>% left_join(., metadata_norm_v2, by="sample") %>% group_by(time24, position) 

#relative expression (divide by basemean)
rhodopsin_relative <-rhodopsin_counts %>% left_join(rhodopsin[,c(2,4)], by="position") %>% mutate(relative_expression=value/baseMean)
rhodrelsum <-rhodopsin_relative %>% group_by(time24, position) %>% summarize(relative_expression_mean=mean(relative_expression), sd=sd(relative_expression)) %>% left_join(., rhodopsin[,c(4:7,12)], by="position")


#line plot with error bars
ggplot(rhodrelsum, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="grey") +
  geom_line() +
  geom_point() +
  plot_theme


```

#sod

```{r}
sod <-master_tax %>% filter(., product== "superoxide dismutase") %>% filter(padj <=0.05) #n=15 genes
mean(sod$baseMean) #okay to take the mean of a mean?
1224.632
sodcounts <-normalized_counts %>% filter(position %in% sod$position) %>% pivot_longer(c(1:36), names_to="sample") %>% left_join(., metadata_norm_v2, by="sample")

sodcounts <- sodcounts %>% left_join(sod[,c(2,4)], by="position") %>% mutate(relative=value/baseMean)
sodrelsummary <- sodcounts %>% group_by(time24, position) %>% summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% left_join(., sod[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(sodrelsummary, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="grey") +
  geom_line() +
  geom_point() +
  plot_theme
```

#glycerol kinase

```{r}
glycerol <- diffex_tax[str_detect(diffex_tax$product, "glycerol kinase"),] #n=29 genes, 23 annotated specifically as glpK
#mean expression
mean(glycerol$baseMean)
898.7927
glycerol$gene <-"glycerol kinase"

glycerol_plot <-normalized_counts %>% filter(position %in% glycerol$position) %>% 
  pivot_longer(c(1:36), names_to="sample")%>% 
  left_join(glycerol[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., glycerol[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(glycerol_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme

```

aconitate hydratase
```{r}
aco <-diffex_tax[str_detect(diffex_tax$product, "aconitate hydratase"),] #n=11

aco_plot <-normalized_counts %>% filter(position %in% aco$position) %>%
pivot_longer(c(1:36), names_to="sample") %>% 
  left_join(aco[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., aco[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(aco_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme
```


#pufMHL
Note that this has a very low base mean of expression
```{r}
photo <- diffex_tax[str_detect(diffex_tax$product, "photosynthetic reaction center"),] #n=11, note that these have very low base mean expression 

photo_plot <-normalized_counts %>% filter(position %in% photo$position) %>%
pivot_longer(c(1:36), names_to="sample") %>% 
  left_join(photo[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., photo[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(photo_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme


```

#bacteriochlorophyll
Note that this has a very low base mean of expression
ATP-dependent prochlorophyllide reductase is non-light-dependent, oxygen-sensitive, found in Halothece
chlorophyllide a reductase is key enzyme for producing bacteriochlorophyll
```{r}
chlorophyll <- diffex_tax[str_detect(diffex_tax$product, "chloro"),] 

bchl_plot <-normalized_counts %>% filter(position %in% chlorophyll$position) %>%
pivot_longer(c(1:36), names_to="sample") %>% 
  left_join(chlorophyll[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., chlorophyll[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(bchl_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme

```

#oxygenic photosynthesis
```{r}
photosystem2 <- diffex_tax[str_detect(diffex_tax$product, "photosystem II"),]

photosystem2_plot <-normalized_counts %>% filter(position %in% photosystem2$position) %>%
pivot_longer(c(1:36), names_to="sample") %>% 
  left_join(photosystem2[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., photosystem2[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(photosystem2_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme

photosystemI <-diffex_tax[str_detect(diffex_tax$product, "photosystem I core protein"),]
photosystemI_plot <-normalized_counts %>% filter(position %in% photosystemI$position) %>%
pivot_longer(c(1:36), names_to="sample") %>% 
  left_join(photosystemI[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., photosystemI[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(photosystemI_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme

```

#Fe-S cluster assembly
```{r}
suf <- diffex_tax[str_detect(diffex_tax$product, "Suf"),] 

suf_plot <-normalized_counts %>% filter(position %in% suf$position) %>%
pivot_longer(c(1:36), names_to="sample") %>% 
  left_join(suf[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., suf[,c(4:6, 9,12,13)], by="position")

#line plot with error bars
ggplot(suf_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme

```

#Phosphate uptake
Pst only not PhoU
```{r}
phosphate <- diffex_tax %>% filter(product== "phosphate ABC transporter permease PstA"| product=="phosphate ABC transporter ATP-binding protein PstB" | product=="phosphate ABC transporter permease subunit PstC" | product=="PstS family phosphate ABC transporter substrate-binding protein")

phosphate_plot <-normalized_counts %>% filter(position %in% phosphate$position) %>%
pivot_longer(c(1:36), names_to="sample") %>% 
  left_join(phosphate[,c(2,4)], by="position") %>% 
  mutate(relative=value/baseMean) %>% 
  left_join(., metadata_norm_v2[,c(2,4)], by="sample") %>% 
  group_by(time24, position) %>% 
  summarise(relative_expression_mean=mean(relative), sd=sd(relative)) %>% 
  left_join(., phosphate[,c(4:6, 9,12,13)], by="position")

ggplot(phosphate_plot, aes(x=time24, y=relative_expression_mean, group=position)) +
  geom_ribbon(aes(ymin=relative_expression_mean-sd, ymax=relative_expression_mean+sd), fill="gray") +
  geom_line() +
  geom_point() +
  plot_theme

```


Visualizing salinibacter ruber expression in SBSW:

201005_12_DNA_2_bin.30, 201005_12_DNA_mat_2_bin.6, 201005_12_DNA_2_bin.48

```{r}

bin48 <-master_tax %>% filter(bin=="201005_12_DNA_2_bin.48")
bin30 <-master_tax %>% filter(bin=="201005_12_DNA_2_bin.30")
bin6 <-master_tax %>% filter(bin=="201005_12_DNA_mat_2_bin.6")
```

MA plots for 3 S. ruber bins as well as the S. ruber genome, vertically aligned 


```{r}

#bin48
bin48 <-as.data.frame(bin48)
bin48$significance <-"FALSE"
bin48$significance[bin48$padj < 0.05] <- "TRUE"
bin48$significance <-as.logical(bin48$significance)

bin48_diffex <- bin48 %>% filter(padj<0.05)
MA_plot <-bin48[,c("baseMean", "log2FoldChange", "significance")]
geneplotter::plotMA(MA_plot, ylim=c(-2,2), colSig="blue", colLine="#ff000080")

#bin30
bin30 <-as.data.frame(bin30)
bin30$significance <-"FALSE"
bin30$significance[bin30$padj < 0.05] <- "TRUE"
bin30$significance <-as.logical(bin30$significance)

bin30_MA_plot <-bin30[,c("baseMean", "log2FoldChange", "significance")]
geneplotter::plotMA(bin30_MA_plot, ylim=c(-2,2), colSig="blue")

#bin6
bin6 <-as.data.frame(bin6)
bin6$significance <-"FALSE"
bin6$significance[bin6$padj < 0.05] <- "TRUE"
bin6$significance <-as.logical(bin6$significance)

bin6_MA_plot <-bin6[,c("baseMean", "log2FoldChange", "significance")]
geneplotter::plotMA(bin6_MA_plot, ylim=c(-2,2), colSig="red")

```



Thoughts on visualizing these genes
-Could create a basemean cutoff to exclude low-count genes. This would have to be consistent across the entire dataset. 


Visualizing how transcription level for bins changes across day/night

```{r}

total_counts_sample <- as.data.frame(colSums(normalized_counts[,c(1:36)])) 
total_counts_sample$sample <-rownames(total_counts_sample)


counts_per_bin <- normalized_counts %>% pivot_longer(c(1:36), names_to="sample", values_to="count") %>% group_by(bin, sample) %>% summarize(counts_per_bin=sum(count))

prop_counts <-left_join(counts_per_bin, total_counts_sample, by="sample") %>% mutate(percent_counts_bin=(counts_per_bin/colSums(normalized_counts[,c(1:36)]))*100)

#Join to higher order taxonomic information
bins <-unique(master_tax$bin)
taxonomy <-read_csv("../mt_data_v2/gtdbtk_results/gtdbtk_full.csv")
sbsw_bins <-taxonomy %>% filter(bin %in% bins)

prop_counts <-left_join(prop_counts, sbsw_bins[,c(1:8)], by="bin")

#make anything with less than 1% 'other?
#more in depth than class?
#average across replicates?

#visualize this on a plot

ggplot(prop_counts, aes(x=sample, y=percent_counts_bin, fill=class)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values=wes_palette_20) +
  plot_theme
```

